[
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "8eac13c0-ae4f-4ca4-a794-beacd970251f",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC001-ai content detection post request with valid text",
    "description": "Test the /api/ai/detect endpoint with valid text input to verify it returns AI vs human probability scores, verdict, confidence, and readability indicators correctly.",
    "code": "import requests\n\ndef test_ai_content_detection_post_request_with_valid_text():\n    base_url = \"http://localhost:5000\"\n    endpoint = \"/api/ai/detect\"\n    url = base_url + endpoint\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"text\": (\n            \"Artificial intelligence (AI) is intelligence demonstrated by machines, \"\n            \"unlike the natural intelligence displayed by humans and animals. Leading AI \"\n            \"text classification models are designed to discern human writing from AI-generated prose \"\n            \"with statistical probability scores.\"\n        )\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    \n    json_response = response.json()\n    \n    # Validate the main response structure\n    assert \"statusCode\" in json_response and isinstance(json_response[\"statusCode\"], int), \"Missing or invalid statusCode\"\n    assert \"message\" in json_response and isinstance(json_response[\"message\"], str), \"Missing or invalid message\"\n    assert \"data\" in json_response and isinstance(json_response[\"data\"], dict), \"Missing or invalid data object\"\n\n    data = json_response[\"data\"]\n\n    # Validate detection object properties\n    detection = data.get(\"detection\")\n    assert detection is not None and isinstance(detection, dict), \"Missing or invalid detection object\"\n    assert \"aiProbability\" in detection and isinstance(detection[\"aiProbability\"], (float, int)), \"Missing or invalid aiProbability\"\n    assert 0.0 <= detection[\"aiProbability\"] <= 1.0, \"aiProbability out of range [0,1]\"\n    assert \"humanProbability\" in detection and isinstance(detection[\"humanProbability\"], (float, int)), \"Missing or invalid humanProbability\"\n    assert 0.0 <= detection[\"humanProbability\"] <= 1.0, \"humanProbability out of range [0,1]\"\n    assert \"verdict\" in detection and isinstance(detection[\"verdict\"], str) and detection[\"verdict\"], \"Missing or invalid verdict\"\n    assert \"confidence\" in detection and isinstance(detection[\"confidence\"], str) and detection[\"confidence\"], \"Missing or invalid confidence\"\n\n    # Validate analysis object\n    analysis = data.get(\"analysis\")\n    assert analysis is not None and isinstance(analysis, dict), \"Missing or invalid analysis object\"\n\n    # Validate indicators is an array of strings\n    indicators = data.get(\"indicators\")\n    assert indicators is not None and isinstance(indicators, list), \"Missing or invalid indicators array\"\n    for indicator in indicators:\n        assert isinstance(indicator, str), \"Indicator item not a string\"\n\n    # Validate metadata is an object\n    metadata = data.get(\"metadata\")\n    assert metadata is not None and isinstance(metadata, dict), \"Missing or invalid metadata object\"\n\ntest_ai_content_detection_post_request_with_valid_text()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.746Z",
    "modified": "2025-11-26T12:51:27.015Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "56aafddf-da1a-42cd-9e10-c22cd10b5282",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC002-article generation with required topic parameter",
    "description": "Test the /api/generate/article endpoint by providing a valid topic and optional keywords and wordCount to ensure it generates a long-form article matching the requested parameters.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_article_generation_with_required_topic_parameter():\n    url = f\"{BASE_URL}/api/generate/article\"\n    payload = {\n        \"topic\": \"The future of artificial intelligence\",\n        \"keywords\": \"AI, machine learning, technology\",\n        \"wordCount\": 1000\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response body is not valid JSON\"\n\n    # Validate the presence of essential parts: article content and metadata\n    assert \"article\" in data or \"content\" in data or \"text\" in data or isinstance(data, dict), \"Response JSON missing expected article content keys\"\n\n    # We do not have exact schema but check if output includes some content string roughly matching requested params\n    article_text = None\n    # Try common keys that might be returned for article text\n    if \"article\" in data and isinstance(data[\"article\"], str):\n        article_text = data[\"article\"]\n    elif \"content\" in data and isinstance(data[\"content\"], str):\n        article_text = data[\"content\"]\n    elif \"text\" in data and isinstance(data[\"text\"], str):\n        article_text = data[\"text\"]\n    elif \"data\" in data and isinstance(data[\"data\"], dict):\n        # Nested data object heuristic\n        for key in (\"article\", \"content\", \"text\"):\n            if key in data[\"data\"] and isinstance(data[\"data\"][key], str):\n                article_text = data[\"data\"][key]\n                break\n\n    assert article_text is not None and isinstance(article_text, str) and len(article_text) > 0, \"Article content is missing or empty in response\"\n\n    # Optionally check if word count is roughly close to requested (allow some tolerance, e.g. ±10%)\n    word_count_requested = payload[\"wordCount\"]\n    article_word_count = len(article_text.split())\n    lower_bound = int(word_count_requested * 0.9)\n    upper_bound = int(word_count_requested * 1.1)\n    assert lower_bound <= article_word_count <= upper_bound, f\"Article word count ({article_word_count}) not within ±10% of requested ({word_count_requested})\"\n\n    # Check that topic or keywords appear somewhere in the article text (case insensitive)\n    assert payload[\"topic\"].lower() in article_text.lower(), \"Article text does not contain the topic\"\n    for kw in payload[\"keywords\"].split(\",\"):\n        kw = kw.strip()\n        if kw:\n            assert kw.lower() in article_text.lower(), f\"Article text does not contain keyword: {kw}\"\n\ntest_article_generation_with_required_topic_parameter()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.752Z",
    "modified": "2025-11-26T12:51:39.998Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "cdba14c1-1705-4eed-b87f-e4d94d3b4754",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC003-seo friendly titles generation with topic and tone",
    "description": "Test the /api/generate/titles endpoint with a valid topic and tone to verify it returns a list of SEO-friendly titles as per the requested count.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_seo_friendly_titles_generation_with_topic_and_tone():\n    url = f\"{BASE_URL}/api/generate/titles\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"topic\": \"sustainable gardening\",\n        \"tone\": \"professional\",\n        \"count\": 5\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Expecting a list of titles - as per PRD, response shape is not explicitly detailed for this endpoint,\n    # so infer that the response returns the list directly, or under a property.\n    # We'll check common expected keys or assume simple list returned.\n\n    # If the response is a dictionary containing the titles list, try common keys first:\n    if isinstance(data, dict):\n        # Try common keys where titles could be found\n        titles = None\n        if \"titles\" in data:\n            titles = data[\"titles\"]\n        elif \"data\" in data and isinstance(data[\"data\"], dict):\n            # perhaps data object contains titles list\n            titles = data[\"data\"].get(\"titles\", None)\n        else:\n            # fallback: check if top-level keys contain list of strings\n            for v in data.values():\n                if isinstance(v, list) and all(isinstance(i, str) for i in v):\n                    titles = v\n                    break\n    elif isinstance(data, list):\n        titles = data\n    else:\n        titles = None\n\n    assert titles is not None, \"Response does not contain titles list\"\n    assert isinstance(titles, list), \"Titles should be returned as a list\"\n    assert len(titles) == payload[\"count\"], f\"Expected {payload['count']} titles, got {len(titles)}\"\n    for title in titles:\n        assert isinstance(title, str), \"Each title should be a string\"\n        assert len(title) > 0, \"Title should not be empty\"\n\ntest_seo_friendly_titles_generation_with_topic_and_tone()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.759Z",
    "modified": "2025-11-26T12:51:28.854Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "c35b6283-10ee-4536-b116-810734ad6188",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC004-inspirational quotes generation with theme and type",
    "description": "Test the /api/generate/quotes endpoint by submitting a theme and type (quote or tagline) to confirm it generates the correct number of inspirational quotes or taglines.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT_SECONDS = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_inspirational_quotes_generation_with_theme_and_type():\n    url = f\"{BASE_URL}/api/generate/quotes\"\n    test_cases = [\n        {\"theme\": \"motivation\", \"type\": \"quote\", \"count\": 3},\n        {\"theme\": \"success\", \"type\": \"tagline\", \"count\": 5},\n        {\"theme\": \"happiness\", \"type\": \"quote\", \"count\": 1},\n        {\"theme\": \"teamwork\", \"type\": \"tagline\", \"count\": 2},\n    ]\n\n    for case in test_cases:\n        payload = {\n            \"theme\": case[\"theme\"],\n            \"type\": case[\"type\"],\n            \"count\": case[\"count\"]\n        }\n        try:\n            response = requests.post(url, headers=HEADERS, json=payload, timeout=TIMEOUT_SECONDS)\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\n        assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n        \n        try:\n            data = response.json()\n        except ValueError:\n            assert False, \"Response is not valid JSON\"\n\n        # The response should include generated quotes/taglines, assume in data field holding a list\n        # Since API doc description is brief, check for a field with list of quotes/taglines\n        # Heuristics: response JSON keys might be { \"quotes\": [...]} or similar\n        # So check common patterns or fallback to keys with list and count matching\n\n        # Try to find a list in response JSON with length matching 'count'\n        list_found = False\n        for key, value in data.items():\n            if isinstance(value, list):\n                list_found = True\n                assert len(value) == case[\"count\"], (\n                    f\"Expected {case['count']} items but got {len(value)} for key '{key}'\"\n                )\n                # Further check non-empty string elements\n                for item in value:\n                    assert isinstance(item, str) and item.strip(), \"Generated item should be non-empty string\"\n                break\n        \n        assert list_found, \"Response JSON does not contain a list of generated quotes or taglines\"\n\n\ntest_inspirational_quotes_generation_with_theme_and_type()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.765Z",
    "modified": "2025-11-26T12:51:47.222Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "09951635-480e-4b9f-8ba8-11a894a12a2f",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC005-text rewrite with various tone modes",
    "description": "Test the /api/generate/rewrite endpoint by providing text and different mode values (standard, formal, casual, creative, concise) to verify the text is rewritten accordingly.",
    "code": "import requests\n\ndef test_text_rewrite_with_various_tone_modes():\n    base_url = \"http://localhost:5000\"\n    endpoint = f\"{base_url}/api/generate/rewrite\"\n    headers = {\"Content-Type\": \"application/json\"}\n    timeout = 30\n    input_text = \"The quick brown fox jumps over the lazy dog.\"\n    modes = [\"standard\", \"formal\", \"casual\", \"creative\", \"concise\"]\n\n    for mode in modes:\n        payload = {\n            \"text\": input_text,\n            \"mode\": mode\n        }\n        try:\n            response = requests.post(endpoint, json=payload, headers=headers, timeout=timeout)\n            response.raise_for_status()\n        except requests.RequestException as e:\n            assert False, f\"Request failed for mode '{mode}': {e}\"\n\n        assert response.status_code == 200, f\"Expected 200 OK for mode '{mode}', got {response.status_code}\"\n\n        try:\n            data = response.json()\n        except ValueError:\n            assert False, f\"Response is not valid JSON for mode '{mode}'\"\n\n        # Expecting the rewritten text in the response; validate presence and type\n        # Based on PRD, the actual schema of response body not fully detailed,\n        # but the description \"Rewritten output\" implies that a string output should be present.\n        # We'll check if there's a 'rewrittenText' or similar key or fallback validate response has text.\n\n        # Since no explicit key name is provided, we accept any string value in response body\n        # We'll assert that response JSON has at least one string value representing rewritten text.\n\n        # Heuristic: response body should have keys and a non-empty string value(s) indicating rewritten text.\n        # We'll check the first string value in the response JSON.\n\n        def find_rewritten_text(obj):\n            if isinstance(obj, dict):\n                for v in obj.values():\n                    result = find_rewritten_text(v)\n                    if result:\n                        return result\n            elif isinstance(obj, list):\n                for item in obj:\n                    result = find_rewritten_text(item)\n                    if result:\n                        return result\n            elif isinstance(obj, str) and len(obj.strip()) > 0:\n                return obj.strip()\n            return None\n\n        rewritten_text = find_rewritten_text(data)\n        assert rewritten_text is not None, f\"No rewritten text found in response for mode '{mode}'\"\n        # Additional sanity: rewritten text should be different than input text or at least non-empty\n        assert len(rewritten_text) > 0, f\"Rewritten text is empty for mode '{mode}'\"\n\ntest_text_rewrite_with_various_tone_modes()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.771Z",
    "modified": "2025-11-26T12:51:37.765Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "9ef123eb-4a0d-47f6-84cf-6303e6d19559",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC006-support ticket classification with text and optional user info",
    "description": "Test the /api/classify/ticket endpoint by submitting support ticket text along with optional email and userId to ensure it returns structured classification results.",
    "code": "import requests\n\ndef test_support_ticket_classification_with_text_and_optional_user_info():\n    base_url = \"http://localhost:5000\"\n    endpoint = \"/api/classify/ticket\"\n    url = base_url + endpoint\n    headers = {\"Content-Type\": \"application/json\"}\n    payload = {\n        \"text\": \"My internet connection has been intermittently dropping over the past week. Please help!\",\n        \"email\": \"user@example.com\",\n        \"userId\": \"user_12345\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n        response.raise_for_status()\n        data = response.json()\n        assert isinstance(data, dict), \"Response is not a JSON object\"\n        # Expected fields in classification response (not strictly defined, so check common keys)\n        assert \"statusCode\" in data or \"status\" in data or True\n        # We expect structured classification result: Check keys like 'category', 'priority', or similar\n        # since exact response keys aren't specified, verify at least it returned JSON with data\n        assert any(key in data for key in [\"data\", \"classification\", \"result\", \"category\", \"triage\"]), \\\n            \"Expected classification result keys missing\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to classify ticket failed: {str(e)}\"\n    except AssertionError as ae:\n        assert False, f\"Assertion failed: {str(ae)}\"\n\ntest_support_ticket_classification_with_text_and_optional_user_info()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.777Z",
    "modified": "2025-11-26T12:51:49.138Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "28ed533f-d88b-4be5-a5a6-14dae325daad",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC007-resume analysis with file upload and job title",
    "description": "Test the /api/classify/resume endpoint by uploading a resume file and providing a job title to verify it returns detailed resume insights and handles file parsing correctly.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_resume_analysis_with_file_upload_and_job_title():\n    endpoint = f\"{BASE_URL}/api/classify/resume\"\n    headers = {}\n    job_title = \"Software Engineer\"\n    \n    # Prepare a sample resume file content (basic resume text in bytes)\n    sample_resume_content = (\n        \"John Doe\\n\"\n        \"Software Engineer\\n\"\n        \"Experience:\\n\"\n        \"- Developed scalable web applications\\n\"\n        \"- Worked with Python, JavaScript, and Node.js\\n\"\n        \"Education:\\n\"\n        \"BSc Computer Science\\n\"\n    ).encode('utf-8')\n    \n    file_like = io.BytesIO(sample_resume_content)\n    file_like.name = \"sample_resume.txt\"\n    files = {'file': (file_like.name, file_like, 'text/plain')}\n    data = {'jobTitle': job_title}\n    \n    response = requests.post(endpoint, headers=headers, files=files, data=data, timeout=TIMEOUT)\n    \n    assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n    resp_json = response.json()\n    \n    # Validate keys in response\n    assert \"statusCode\" in resp_json and resp_json[\"statusCode\"] == 200\n    assert \"message\" in resp_json\n    assert \"data\" in resp_json and isinstance(resp_json[\"data\"], dict)\n    \n    data_field = resp_json[\"data\"]\n    # Expect some kind of insights in data\n    assert any(k in data_field for k in (\"resumeInsights\", \"analysis\", \"score\", \"match\", \"details\")) or len(data_field) > 0\n\n\ntest_resume_analysis_with_file_upload_and_job_title()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.783Z",
    "modified": "2025-11-26T12:52:02.187Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "aebfbca4-71fd-411d-807a-32066862c61d",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC008-sentiment scoring with text input",
    "description": "Test the /api/classify/sentiment endpoint by submitting text to confirm it returns sentiment label and confidence score accurately.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nENDPOINT = \"/api/classify/sentiment\"\nTIMEOUT = 30\n\ndef test_sentiment_scoring_with_text_input():\n    url = BASE_URL + ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"text\": \"I really love using this product! It has improved my workflow tremendously.\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    try:\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(json_data, dict), \"Response JSON is not a dictionary\"\n\n    # Expecting 'data' object containing 'label' and 'confidence'\n    assert 'data' in json_data, \"'data' key not found in response\"\n    data = json_data['data']\n    assert isinstance(data, dict), \"'data' is not a dictionary\"\n\n    assert 'label' in data, \"'label' key not found in data\"\n    sentiment = data['label']\n    assert isinstance(sentiment, str), \"Sentiment label is not a string\"\n    accepted_labels = [\"positive\", \"negative\", \"neutral\", \"very positive\", \"very negative\"]\n    assert sentiment.lower() in accepted_labels, f\"Unexpected sentiment label: {sentiment}\"\n\n    assert 'confidence' in data, \"'confidence' key not found in data\"\n    confidence = data['confidence']\n    assert isinstance(confidence, (float, int)), \"Confidence score is not numeric\"\n    assert 0 <= confidence <= 1, f\"Confidence score out of range: {confidence}\"\n\n\ntest_sentiment_scoring_with_text_input()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.789Z",
    "modified": "2025-11-26T12:52:14.305Z"
  },
  {
    "projectId": "a05a2a4b-c4a2-4e8c-bcd8-c6f2272fdfa2",
    "testId": "47deb2de-520e-4d49-89ef-d0e6e53fac5c",
    "userId": "84a8a478-b0b1-7082-eb93-8c64efbe76c3",
    "title": "TC009-document qa assistant with file upload and user question",
    "description": "Test the /api/assistant/respond endpoint by uploading a document file and submitting a user question to verify it returns AI-generated answers strictly based on the document content.",
    "code": "import requests\nimport io\n\ndef test_tc009_document_qa_assistant_with_file_upload_and_user_question():\n    base_url = \"http://localhost:5000\"\n    endpoint = f\"{base_url}/api/assistant/respond\"\n    timeout = 30\n    headers = {}\n\n    # Prepare a simple document content for upload (a small text file)\n    document_content = b\"Python is a high-level programming language. It is widely used for web development, data analysis, AI, and more.\"\n    file_tuple = ('test_document.txt', io.BytesIO(document_content), 'text/plain')\n\n    user_question = \"What is Python used for?\"\n\n    try:\n        files = {\n            'file': file_tuple\n        }\n        data = {\n            'user_input': user_question\n        }\n\n        response = requests.post(endpoint, files=files, data=data, headers=headers, timeout=timeout)\n        assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n        json_response = response.json()\n\n        # Validate response contains AI-generated answer related to the document content\n        assert 'answer' in json_response or 'data' in json_response, \"Response missing expected answer data\"\n\n        # Heuristic checks on answer presence and type\n        answer_text = None\n        if 'answer' in json_response:\n            answer_text = json_response['answer']\n        elif 'data' in json_response and isinstance(json_response['data'], dict):\n            # Try to find answer inside data object\n            for key in ['answer', 'response', 'content']:\n                if key in json_response['data']:\n                    answer_text = json_response['data'][key]\n                    break\n\n        assert answer_text is not None, \"Answer text not found in response\"\n        assert isinstance(answer_text, str), \"Answer text should be a string\"\n        assert len(answer_text.strip()) > 0, \"Answer text is empty\"\n\n        # Check that the answer is related to the document context (basic containment check)\n        # We'll check it contains the word 'Python' since that is the core content\n        assert \"Python\" in answer_text or \"python\" in answer_text, \"Answer does not appear grounded in document content\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n\n\ntest_tc009_document_qa_assistant_with_file_upload_and_user_question()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-26T12:51:05.795Z",
    "modified": "2025-11-26T12:51:55.054Z"
  }
]
